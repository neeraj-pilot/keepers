#!/usr/bin/env python3
"""
Keepers Secret Recovery Tool

Recovers secrets from Shamir Secret Sharing shares generated by Keepers.
Uses GF(256) with primitive polynomial x^8 + x^4 + x^3 + x^2 + 1 (0x11d).

Usage:
    python recover.py <share1> <share2> [share3] ...

Example:
    python recover.py 0302abc123... 0301def456...
"""

import sys

# GF(256) primitive polynomial: x^8 + x^4 + x^3 + x^2 + 1
PRIMITIVE_POLY = 0x11d

# Precompute log and exp tables for GF(256)
LOG_TABLE = [0] * 256
EXP_TABLE = [0] * 256

def init_tables():
    x = 1
    for i in range(255):
        EXP_TABLE[i] = x
        LOG_TABLE[x] = i
        x <<= 1
        if x & 0x100:
            x ^= PRIMITIVE_POLY
    EXP_TABLE[255] = EXP_TABLE[0]

init_tables()

def gf_mul(a: int, b: int) -> int:
    """Multiply two numbers in GF(256)"""
    if a == 0 or b == 0:
        return 0
    return EXP_TABLE[(LOG_TABLE[a] + LOG_TABLE[b]) % 255]

def gf_div(a: int, b: int) -> int:
    """Divide two numbers in GF(256)"""
    if b == 0:
        raise ValueError("Division by zero")
    if a == 0:
        return 0
    return EXP_TABLE[(LOG_TABLE[a] - LOG_TABLE[b] + 255) % 255]

def lagrange_interpolate(points: list[tuple[int, int]]) -> int:
    """
    Lagrange interpolation to find f(0) in GF(256).
    points: list of (x, y) tuples
    """
    result = 0
    for i, (xi, yi) in enumerate(points):
        numerator = 1
        denominator = 1
        for j, (xj, _) in enumerate(points):
            if i != j:
                numerator = gf_mul(numerator, xj)
                denominator = gf_mul(denominator, xi ^ xj)
        result ^= gf_mul(yi, gf_div(numerator, denominator))
    return result

def decode_share(share_hex: str) -> tuple[int, int, bytes]:
    """
    Decode a hex-encoded share.
    Returns: (threshold, x_value, data_bytes)
    """
    share_bytes = bytes.fromhex(share_hex)
    threshold = share_bytes[0]
    x_value = share_bytes[1]
    data = share_bytes[2:]
    return threshold, x_value, data

def combine_shares(shares: list[str]) -> str:
    """
    Combine shares to recover the secret.
    shares: list of hex-encoded share strings
    """
    if len(shares) < 2:
        raise ValueError("Need at least 2 shares")

    # Decode all shares
    decoded = [decode_share(s.strip()) for s in shares]

    # Verify consistency
    threshold = decoded[0][0]
    data_len = len(decoded[0][2])

    for t, x, data in decoded:
        if t != threshold:
            raise ValueError(f"Threshold mismatch: expected {threshold}, got {t}")
        if len(data) != data_len:
            raise ValueError(f"Data length mismatch: expected {data_len}, got {len(data)}")

    if len(shares) < threshold:
        raise ValueError(f"Need at least {threshold} shares, only got {len(shares)}")

    # Check for duplicate x values
    x_values = [d[1] for d in decoded]
    if len(x_values) != len(set(x_values)):
        raise ValueError("Duplicate shares detected")

    # Reconstruct each byte using Lagrange interpolation
    secret_bytes = bytearray(data_len)
    for byte_idx in range(data_len):
        points = [(d[1], d[2][byte_idx]) for d in decoded]
        secret_bytes[byte_idx] = lagrange_interpolate(points)

    return secret_bytes.decode('utf-8')

def main():
    # If shares provided as arguments, use them
    if len(sys.argv) >= 3:
        shares = sys.argv[1:]
    else:
        # Interactive mode
        print("Keepers Secret Recovery Tool")
        print("=" * 40)
        print("Enter your shares one at a time.")
        print("Press Enter on an empty line when done.")
        print()

        shares = []
        while True:
            prompt = f"Share {len(shares) + 1}: "
            try:
                share = input(prompt).strip()
            except EOFError:
                break

            if not share:
                if len(shares) >= 2:
                    break
                else:
                    print(f"Need at least 2 shares. You have {len(shares)}.")
                    continue

            # Basic validation
            if not all(c in '0123456789abcdefABCDEF' for c in share):
                print("Invalid share format. Shares should be hex strings.")
                continue

            shares.append(share)
            print(f"  Added share {len(shares)}")

        print()

    if len(shares) < 2:
        print("Error: Need at least 2 shares")
        sys.exit(1)

    try:
        secret = combine_shares(shares)
        print("=" * 40)
        print("Recovered secret:")
        print()
        print(secret)
        print()
    except ValueError as e:
        print(f"Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Failed to recover secret: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
